---
title: make
date: 2019-10-23 17:50:39
categories: ["Linux"]
---

`make` 是构建大型项目的首选方案。

## Makefile
Makefile 基本格式:
```
target ... : prerequisites ...
    command
    ...
```

- `target` - 目标，目标通常是文件名，Make 命令所要构建的对象。
- `prerequisites` - 前置条件，通常是一组文件名，之间用空格分隔。
- `command` - 命令，生成目标所需要执行的命令，由一行或多行的 shell 命令组成，是构建 `target` 的具体指令。

> **Makefile 中的命令必须以 `[tab]` 开头**。

### target
一个 target 构成一条规则。target 可以是一个文件名，也可以是多个文件名，之间用空格分隔。

运行 make 时没有指定目标，默认会执行 Makefile 文件的第一个目标。

#### 伪目标
当 target 是某个操作的名字时，被称为**伪目标**（phony target）。

```makefile
clean:
	rm -f apiserver
```

`clean` 就是伪目标，做一些清理操作。

```sh
make clean
```

如果当前目录中，存在一个文件叫做 `clean`，那么 `clean` 操作不会执行。因为 Make 任务 `clean` 已经存在，不需要重新构建。

这个时候可以声明 `clean` 是"伪目标"：
```makefile
.PHONY: clean
clean:
    rm -f apiserver
```

声明"伪目标"之后， make 就不会检查 `clean` 文件是否存在。

`.PHONY:` 后面可以声明一个或多个伪目标，之间用空格分隔。

### prerequisites
prerequisites 指定了 target 是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新，target 就需要重新构建。

```makefile
.PHONY: buildimg
buildimg: apisevergo
    cp apisevergo /apisevergo

apisevergo:
    ./build_binary.sh
```

上面的示例，`buildimg` 的前置条件是 `apisevergo`。如果 `apisevergo` 已经存在，那么 `make buildimg` 可以正常运行，
**否则必须再写一条规则，来生成 `apisevergo`**。

```sh
make buildimg
make buildimg
```

上面连续执行两次 `make buildimg`。第一次执行会先生成 `apisevergo`，然后再执行 `cp apisevergo /apisevergo`。
第二次执行，make 发现 apisevergo 存在而且没有变动，就不会执行任何操作。

### command
command 是构建 target 的具体指令，它的运行结果通常就是生成目标文件。

命令必须以 `[tab]` 开头，可以用内置变量 `.RECIPEPREFIX` 声明，来使用其他键。
```makefile
.RECIPEPREFIX = >
all:
> echo Hello, world
```

`.RECIPEPREFIX`指定了 `>` 替代 `tab` 键。

**每行命令在一个单独的 shell 中执行。也就是说 shell 之间没有继承关系**。
```makefile
var-lost:
    export foo=bar
    echo "foo=[$$foo]"
```
执行 `var-lost` 取不到 `foo` 的值。因为两行命令在两个不同的进程执行。有三种解决办法：
1. 将两行命令写在一行，中间用分号分隔。
2. 在换行符前加反斜杠转义。
3. 使用 `.ONESHELL`
```makefile
# 1
var-kept:
    export foo=bar; echo "foo=[$$foo]"

# 2
var-kept2:
    export foo=bar; \
    echo "foo=[$$foo]"

# 3
.ONESHELL:
var-kept3:
    export foo=bar;
    echo "foo=[$$foo]"
```

## 构建 Go 项目