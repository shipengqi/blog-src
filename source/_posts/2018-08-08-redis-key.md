---
title: Redis Key操作
date: 2018-08-08 15:58:39
categories: ["Linux"]
tags: ["Redis"]
---

在日常开发中，查找某个，或某些铁定前缀的`key`，修改他们的值，删除`key`，都是很常用的操作。`Redis`如何从海量的`key`中找出满足特定前缀的`key`列表？
使用`Redis`的`keys`指令。

<!-- more -->

## 查找删除
### KEYS
按指定的正则匹配模式`pattern`查找`key`。

```bash
KEYS pattern
```

- `KEYS *`匹配数据库中所有的`key`
- `KEYS h?llo`匹配 hello、hallo、hxllo 等
- `KEYS h*llo`匹配 hllo、heeeeello等
- `KEYS h[ae]llo`匹配 hello、hallo，但不匹配 hillo

`KEYS`指令非常简单，但是有两个缺点：
- 没有 offset、limit 参数，会返回所有匹配到的`key`。
- 执行`KEYS`会遍历所有的`key`，如果`Redis`存储了海量的`key`，由于`Redis`是单线程，`KEYS`指令就会阻塞其他指令，直到`KEYS`执行完毕。

所以在数据量很大的情况下，不建议使用`KEYS`，会造成`Redis`服务卡顿，导致其他的指令延时甚至超时报错。
`Redis`提供了`SCAN`指令来解决这个问题，参考`SCAN`。

```bash
# 4 个测试数据
redis> MSET one 1 two 2 three 3 four 4
OK

redis> KEYS *o*
1) "four"
2) "two"
3) "one"

redis> KEYS t??
1) "two"

redis> KEYS t[w]*
1) "two"

# 匹配数据库内所有 key
redis> KEYS *
1) "four"
2) "three"
3) "two"
4) "one"
```
### EXISTS
判断`key`是否存在。
```bash
EXISTS key
```
存在返回`1`，不存在返回`0`。
```bash
redis> SET db "redis"
OK

redis> EXISTS db
(integer) 1

redis> DEL db
(integer) 1

redis> EXISTS db
(integer) 0
```
### RANDOMKEY
随机返回一个`key`
```bash
# 设置多个 key
redis> MSET fruit "apple" drink "beer" food "cookies"
OK

redis> RANDOMKEY
"fruit"

redis> RANDOMKEY
"food"

# 返回 key 但不删除
redis> KEYS *
1) "food"
2) "drink"
3) "fruit"

# 删除当前数据库所有 key，数据库为空
redis> FLUSHDB
OK
redis> RANDOMKEY
(nil)
```
### TYPE
返回`key`的值的类型。`key`不存在返回`none`，否则返回值得类型`string`，`list`，`set`，`zset`，`hash`。
```bash
# 字符串
redis> SET weather "sunny"
OK
redis> TYPE weather
string

# 列表
redis> LPUSH book_list "programming in scala"
(integer) 1
redis> TYPE book_list
list

# 集合
redis> SADD pat "dog"
(integer) 1
redis> TYPE pat
set
```
### SORT
### DEL
删除一个或多个`key`。
```bash
DEL key [key ...]
```
返回被删除的`key`的数量。
```bash
#  删除单个 key

redis> SET name huangz
OK

redis> DEL name
(integer) 1


# 删除一个不存在的 key

redis> EXISTS phone
(integer) 0

redis> DEL phone # 失败，没有 key 被删除
(integer) 0


# 同时删除多个 key

redis> SET name "redis"
OK

redis> SET type "key-value store"
OK

redis> SET website "redis.com"
OK

redis> DEL name type website
(integer) 3
```
## 重命名

### RENAME
将`key`重命名为`newkey`。
```bash
RENAME key newkey
```
如果`key`和`newkey`相同，或`key`不存在，返回一个错误。当`newkey`已存在，覆盖`newkey`。
```bash
# key 存在且 newkey 不存在
redis> SET message "hello world"
OK
redis> RENAME message greeting
OK

# message 不复存在
redis> EXISTS message
(integer) 0
# 已被重命名为 greeting
redis> EXISTS greeting
(integer) 1


# 当 key 不存在时，返回错误
redis> RENAME fake_key never_exists
(error) ERR no such key


# newkey 已存在时， RENAME 会覆盖旧 newkey
redis> SET pc "lenovo"
OK
redis> SET personal_computer "dell"
OK
redis> RENAME pc personal_computer
OK
redis> GET pc
(nil)
# 原来的值 dell 被覆盖了
redis:1> GET personal_computer
"lenovo"
```
### RENAMENX
与`RENAME`类似，不同的是`RENAMENX`只有在`newkey`不存在的时候，才会重命名。
```bash
RENAMENX key newkey
```
如果`newkey`已经存在返回`0`。
```bash
# newkey 不存在时，重命名成功
redis> SET player "MPlyaer"
OK
redis> EXISTS best_player
(integer) 0
redis> RENAMENX player best_player
(integer) 1

# newkey存在时，失败
redis> SET animal "bear"
OK
redis> SET favorite_animal "butterfly"
OK
redis> RENAMENX animal favorite_animal
(integer) 0
redis> get animal
"bear"
redis> get favorite_animal
"butterfly"
```
## 序列化和反序列化
### DUMP
序列化指定的`key`的值，并返回被序列化的值。
```bash
redis> SET greeting "hello, dumping world!"
OK

redis> DUMP greeting
"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"

redis> DUMP not-exists-key
(nil)
```

### RESTORE
将序列化的值反序列化，并将反序列化的值存储到指定的`key`。
```bash
RESTORE key ttl serialized-value
```
`ttl`表示以毫秒为单位设置`key`的生存时间；如果`ttl`值为`0`，表示不设置生存时间。
`Redis`在进行反序化前，首先会对序列化值进行`RDB`较验，如果版本不符或数据不完整，会拒绝反序列化并返回一个错误
```bash
redis> SET greeting "hello, dumping world!"
OK

redis> DUMP greeting
"\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"

redis> RESTORE greeting-again 0 "\x00\x15hello, dumping world!\x06\x00E\xa0Z\x82\xd8r\xc1\xde"
OK

redis> GET greeting-again
"hello, dumping world!"

# 使用错误的值进行反序列化
redis> RESTORE fake-message 0 "hello moto moto blah blah"   ;
(error) ERR DUMP payload version or checksum are wrong
```
## 生存时间
### EXPIRE
为指定的`key`设置生存时间。当生存时间为`0`时，`key`会自动删除。
`key`设置生存时间后，可以再次执行`EXPIRE`命令更新生存时间。
**注意对`key`的值进行修改甚至使用`RENAME`对`key`进行重命名时，都不会修改`key`的生存时间**
```bash
EXPIRE key seconds
```
如果`key`不存在或者不能设置生存时间时，返回`0`。
```bash
redis> SET cache_page "www.google.com"
OK

# 设置过期时间为 30 秒
redis> EXPIRE cache_page 30
(integer) 1

# 查看剩余生存时间
redis> TTL cache_page
(integer) 23

# 更新过期时间
redis> EXPIRE cache_page 30000
(integer) 1

redis> TTL cache_page
(integer) 29996
```
### EXPIREAT
与`EXPIRE`命令类似，不同的是`EXPIREAT`设置的生存时间是`UNIX`时间戳。
```bash
redis> SET mykey "Hello"
OK
redis> EXISTS mykey
(integer) 1
redis> EXPIREAT mykey 1293840000
(integer) 1
redis> EXISTS mykey
(integer) 0
```

```bash
```
### PERSISTAT
### PERSIST
### TTL
### PTTL

##
### MIGRATE
### MOVE

## SCAN

##
### OBJECT
