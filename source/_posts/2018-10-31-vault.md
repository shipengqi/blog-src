---
title: Vault 入门
date: 2018-10-31 11:25:59
categories: ["Linux"]
tags: ["Vault"]
---

vault 是一个开源的，强大的密码管理工具。

## 安装

[下载地址](https://www.vaultproject.io/downloads.html)。

```bash
wget wget https://releases.hashicorp.com/vault/0.11.4/vault_0.11.4_linux_amd64.zip
mv ./vault_0.11.4_linux_amd64.zip /usr/local/program/

# 解压 得到一个二进制文件 vault
unzip vault_0.11.4_linux_amd64.zip

# 配置环境变量
vim /etc/profile

# 添加下面的内容 /usr/local/program 改成你自己的安装目录
VAULT_PATH=/usr/local/program
export PATH=$VAULT_PATH:$PATH

# 使环境变量生效
source /etc/profile

# 验证 vault
vault

# 安装 子命令、标志和路径参数的命令行补全 自动安装helper 到 ~/.bashrc
vault -autocomplete-install
exec $SHELL
```

## 启动 server
Vault 用作客户机/服务器应用程序。Vault server 是 Vault 架构中唯一与数据存储和后端交互的部分。通过 Vault CLI 完成的所有操作都通过 TLS 连接与服务器交互。

### 启动 Vault server

首先我们开启Vault的开发服务器，开发服务器是一个内置的、预先配置好的服务器，它不是很安全，但对于本地使用 Vault 非常有用。只能用于开发环境。
运行：
```bash
vault server -dev

# 输出
==> Vault server configuration:

             Api Address: http://127.0.0.1:8200
                     Cgo: disabled
         Cluster Address: https://127.0.0.1:8201
              Listener 1: tcp (addr: "127.0.0.1:8200", cluster address: "127.0.0.1:8201", max_request_duration: "1m30s", max_request_size: "33554432", tls: "disabled")
               Log Level: (not set)
                   Mlock: supported: true, enabled: false
                 Storage: inmem
                 Version: Vault v0.11.4
             Version Sha: 612120e76de651ef669c9af5e77b27a749b0dba3

WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory
and starts unsealed with a single unseal key. The root token is already
authenticated to the CLI, so you can immediately begin using Vault.

You may need to set the following environment variable:

    $ export VAULT_ADDR='http://127.0.0.1:8200'

The unseal key and root token are displayed below in case you want to
seal/unseal the Vault or re-authenticate.

Unseal Key: MG/XNYH+rCMgPE8QMIisDSRBmiNpzAmUI/Rj75RZ/XY=
Root Token: 2oYMZEsFTi9bfeqKIcwwKMxP

Development mode should NOT be used in production installations!

==> Vault server started! Log data will stream in below:

# ...
```

这是 Vault 开发服务器已经启动，不要关闭终端选项卡，打开一个新的选项卡，运行其他命令。

开发服务器所有的数据都存储在内存（加密的），在没有TLS的localhost上侦听，并自动解封并显示解封键和根访问键。

开发服务器运行后，先做下面三件事：
1. 打开一个新的终端会话。
2. 复制并运行上面终端输出的命令`export VAULT_ADDR='http://127.0.0.1:8200'`，这会配置 Vault 客户端与我们的 dev 服务器通信。
3. 复制终端输出的`Unseal Key`和`Root Token`，保存到任意的地方。

### 校验 server 是否运行
打开新的终端，运行`export VAULT_ADDR='http://127.0.0.1:8200'`：
```bash
# 校验
vault status

# 输出
Key             Value
---             -----
Seal Type       shamir
Initialized     true
Sealed          false
Total Shares    1
Threshold       1
Version         0.11.4
Cluster Name    vault-cluster-8ffc02c5
Cluster ID      6a450d7d-e4aa-b636-e338-619aff7c3626
HA Enabled      false
```

如果输出看起来不一样，特别是如果数字不同或 Vault 是`sealed`，那么重新启动 dev 服务器并再次尝试。

## 简单使用
Vault 的核心特性之一就是安全读写任意的 secrets 。可以通过 CLI，但是也有一个完整的[HTTP API](https://www.vaultproject.io/api/index.html)，可以通过编程的方式
使用 Vault 做任何事情。

### 写

写入 Vault 的信息会被加密，然后再写入后端存储。对于 dev server，后端存储是在内存中，但是在生产环境下，应该是磁盘或者[Consul](https://www.consul.io/)。
Vault 在将值传递给存储驱动程序之前对其进行加密。后端存储机制永远不会看到未加密的值，在没有 Vault 的情况下，也没有方法解密它。

使用`vault kv`命令写入：
```bash
vault kv put secret/hello foo=world

# 写入多对
vault kv put secret/hello foo=world excited=yes
```
将一对值`foo=world`写入路径`secret/hello`。这个路径的前缀是`secret/`很重要，否则这个示例将无法工作。`secret/`前缀是任意密码可以读写的地方。

`vault kv put`是一个非常强大的命令。除了直接从命令行写入数据外，它还可以从`STDIN`以及文件中读取值和密钥对。
更多信息，参阅[命令文档](https://www.vaultproject.io/docs/commands/index.html)。

> **但如果可能的话，使用文件更安全。通过 CLI 发送数据通常记录在`shell`历史记录中。对于重要 secrets ，请使用文件。**

### 读
使用`vault get`读取：
```bash
vault kv get secret/hello

# 输出
====== Metadata ======
Key              Value
---              -----
created_time     2018-10-31T06:05:53.226450737Z
deletion_time    n/a
destroyed        false
version          2

===== Data =====
Key        Value
---        -----
excited    yes
foo        world
```
Vault 从存储中获取数据并解密。

添加参数`-format=json`，可以输出`json`格式：
```bash
vault kv get -format=json secret/hello

# 输出
{
  "request_id": "3496c75c-9247-4d49-7ac4-8d821aa0bf43",
  "lease_id": "",
  "lease_duration": 0,
  "renewable": false,
  "data": {
    "data": {
      "excited": "yes",
      "foo": "world"
    },
    "metadata": {
      "created_time": "2018-10-31T06:05:53.226450737Z",
      "deletion_time": "",
      "destroyed": false,
      "version": 2
    }
  },
  "warnings": null
}

# 可以结合 jq 使用
vault kv get -format=json secret/hello | jq -r .data.data.excited

# 输出
yes
```

也可以直接获取指定的字段：
```bash
vault kv get -field=excited secret/hello

# 输出
yes
```

### 删除
`vault delete`命令删除：
```bash
vault kv delete secret/hello

# 输出
Success! Data deleted (if it existed) at: secret/hello
```

## Secrets 引擎
我们前面的读写操作。路径都以`secret/`开头。如果尝试使用不同的前缀，Vault会返回一个错误:
```bash
vault write foo/bar a=b

# 输出
Error writing data to foo/bar: Error making API request.

URL: PUT http://127.0.0.1:8200/v1/foo/bar
Code: 404. Errors:

* no handler for route 'foo/bar'
```

路径前缀告诉 Vault 应该路由到哪个 secrets 引擎。当请求到达 Vault 时，它使用最长的前缀匹配，匹配初始路径部分，然后将请求传递给相应的 secrets 引擎。

默认情况下，Vault 在路径`secret/`上启用了一个名为`kv`的 secrets 引擎。`kv` secrets 引擎将原始数据读写到后端存储。

Vault 除了`kv`还支持多种 secrets 引擎，这个特性使 Vault 变得灵活。例如，`aws` secrets 引擎根据需要生成`aws IAM`访问密钥。
`database` secrets 引擎生成按需的、有时间限制的数据库凭证。

为了简单，Vault 提供的这些 secrets 引擎了类似于文件系统。一个 secrets 引擎启用在一个路径上。Vault 本身在传入请求上执行前缀路由，
并根据启用的路径将请求路由到正确的 secrets 引擎。

### 启用一个 secrets 引擎
我们启用一个`kv`  secrets 引擎在一个不同的路径上，像文件系统一样，我们可以启用一个 secrets 引擎在多个不同的路径上。
每个路径都是完全隔离的，不能与其他路径通信。例如，在`foo`路径上的`kv` secrets 引擎,不能和在`bar`路径上的`kv` secrets 引擎通信。
启用：
```bash
vault secrets enable -path=kv kv

# 输出
Success! Enabled the kv secrets engine at: kv/
```

在`kv/`路径上启用了`kv` secrets 引擎。启用 secrets 引擎的路径默认是 secrets 引擎的名称。也就是说`vault secrets enable kv`和上面的命令
是一样的效果。

查看是否操作成功，获取 secrets 引擎更多信息，使用`vault secrets list`命令：
```bash
vault secrets list

# 输出 n/a 表示没有描述
Path          Type         Accessor              Description
----          ----         --------              -----------
cubbyhole/    cubbyhole    cubbyhole_acf26a2e    per-token private secret storage
identity/     identity     identity_3cdd7b91     identity store
kv/           kv           kv_457c99be           n/a
secret/       kv           kv_548de4c3           key/value secret storage
sys/          system       system_6ab143cf       system endpoints used for control, policy and debugging
```

### 禁用一个 secrets 引擎
如果 secrets 引擎被禁用了，那么所有的 secrets 会被撤销，相应的 Vault 数据和配置会被删除。任何将数据路由到该路径的请求都会导致错误，
但是现在该路径可以启用另一个 secrets 引擎了。

如果由于某种原因，Vault无法删除数据或撤销租约，禁用操作将失败。如果发生这种情况，secrets 引擎将保持启用和可用，但是请求将返回一个错误。

```bash
vault secrets disable kv/
```

注意这个命令的参数不是 secrets 引擎的类型，而是 secrets 引擎对应的路径。

还可以将 secrets 引擎移动到新的路径。这仍然是一个破坏性的命令。所有配置数据都被保留，但是任何 secrets 都被撤销，因为 secrets 与引擎的路径紧密相连。

### secrets 引擎是什么？

上面提到，Vault 的行为类似于虚拟文件系统。`get/write/delete/list`操作被转发到相应的 secrets 引擎，secrets 引擎决定如何对这些操作作出反应。

这种抽象非常强大。它使 Vault 可以直接与物理系统、数据库、HSMs等进行交互。但是除了这些物理系统之外，Vault 还可以与更独特的环境进行交互，比如AWS IAM，动态SQL用户创建，
并且同时使用相同的读写接口。

## Dynamic Secrets
和`kv` secrets 不同的是，你不要自己将数据放入存储中，Dynamic secrets 是在访问它们时生成的。Dynamic secrets 在被读取之前是不存在的，
因此不存在有人窃取它们或其他客户使用相同 secrets 的风险。由于 Vault 具有内置的撤销机制，在使用后可以立即撤销 Dynamic secrets，从而最小化了 secrets 存在的时间。

### 启用 AWS Secrets 引擎
AWS secrets 引擎不像`kv` secrets 引擎一样被默认启用，需要自己在使用前启用。
```bash
vault secrets enable -path=aws aws
```
正如我们在前几节中所讨论的，不同的 secrets 引擎允许不同的行为。这个例子中，AWS secrets引擎生成动态的、按需的AWS访问凭证。

### 配置 AWS Secrets 引擎
在启用 AWS secrets 引擎之后，必须将其配置为进行身份验证并与AWS进行通信。这需要特权帐户凭证。如果您不熟悉AWS，请使用根帐户密钥（**不要在生产环境下使用根帐户密钥**）。

```bash
vault write aws/config/root \
   access_key=AKIAI4SGLQPBX6CSENIQ \
   secret_key=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

# 输出
Success! Data written to: aws/config/root
```
这些凭证现在存储在这个AWS secrets 引擎中。在将来的请求中，引擎将在与AWS通信时使用这些凭证。

### 创建`role`
配置一个`role`，Vault 中`role`是对操作友好的标识符。把它看作一个符号链接。

Vault 知道如何通过AWS API创建IAM用户，但是它不知道想要附加到该用户的权限、组和策略。这就是`role`的作用——`role`将你的配置选项映射到那些API调用。

例如，这里有一个支持EC2上所有操作的IAM策略。当Vault生成访问密钥时，它将自动附加此策略。生成的访问密钥访问EC2(由此策略决定)的所有权限，但不能访问IAM或其他AWS服务。

```bash
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Stmt1426528957000",
      "Effect": "Allow",
      "Action": ["ec2:*"],
      "Resource": ["*"]
    }
  ]
}
```

如上所述，我们需要将这个策略文档映射到一个指定的`role`。为此，向`aws/roles/:name`这里`:name`是描述角色的唯一名称(比如`aws/roles/my-role`):
```bash
vault write aws/roles/my-role policy=-<<EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "Stmt1426528957000",
      "Effect": "Allow",
      "Action": [
        "ec2:*"
      ],
      "Resource": [
        "*"
      ]
    }
  ]
}
EOF

# 输出
Success! Data written to: aws/roles/my-role
```

### 生成 Secret
现在，AWS secrets 引擎已经启用并配置了一个`role`，我们可以通过从AWS`/creds/:name`（`:name`对应一个已经存在的`role`name）中读取来请求 Vault 为该`role`生成一
个访问密钥对:
```bash
vault read aws/creds/my-role

# 输出
Key                Value
---                -----
lease_id           aws/creds/my-role/0bce0782-32aa-25ec-f61d-c026ff22106e
lease_duration     768h
lease_renewable    true
access_key         AKIAJELUDIANQGRXCTZQ
secret_key         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
security_token     <nil>
```

`access key`和`secret key`现在可以用于在AWS中执行任何EC2操作。注意，这些`key`是新的，它们不是你先前输入的`key`.
如果你要再次运行该命令，你会得到一个新的访问密钥对。每次从`aws/creds/:name`中读取数据时，Vault 就会连接到 aws 并生成一个新的IAM用户和密钥对。

注意输出中的`lease_id`字段。此值用于更新、撤销和检查。将此`lease_id`复制到剪贴板。注意，`lease_id`是完整的路径，而不仅仅是末尾的 UUID。

### 撤销 Secret
Vault 将在768小时后自动撤销此凭据(查看上面输出中的`lease_duration`字段)，但我们可能希望尽早撤销它。一旦密钥被撤销，访问密钥就不再有效。

若要撤消 Secret ，使用`vault revoke`加上之前保存的`lease_id`:
```bash
$ vault lease revoke aws/creds/my-role/0bce0782-32aa-25ec-f61d-c026ff22106

Success! Revoked lease: aws/creds/my-role/0bce0782-32aa-25ec-f61d-c026ff22106e
```

完成了!如果要登录到AWS帐户，会看到不存在IAM用户。如果尝试使用生成的访问键，会发现它们不再工作。

有了这样简单的动态创建和撤销，就可以开始看到使用 Dynamic Secrets 是多么容易，并确保它们只在需要的时间内存在。

## 内置的帮助

你现在已经使用了`vault write`和`vault read`来处理多个路径:`kv` secrets 引擎(带有`kv/`)和AWS secrets 引擎提供商(位于`aws/`)的动态AWS证书。

在这两种情况下，每个 secrets 引擎的结构和用法都不同，例如AWS后端有一些特殊的路径，比如`aws/config`。

Vault 有一个内置的帮助系统，而不是必须不断地记住或参考文档以确定使用什么路径。这个帮助系统可以通过API或命令行访问，并为任何路径生成可读的帮助。
使用`vault path-help`命令：
```bash
$ vault path-help aws

### DESCRIPTION

The AWS backend dynamically generates AWS access keys for a set of
IAM policies. The AWS access keys have a configurable lease set and
are automatically revoked at the end of the lease.

After mounting this backend, credentials to generate IAM keys must
be configured with the "root" path and policies must be written using
the "roles/" endpoints before any access keys can be generated.

### PATHS

The following paths are supported by this backend. To view help for
any of the paths below, use the help command with any route matching
the path pattern. Note that depending on the policy of your auth token,
you may or may not be able to access certain paths.

    ^config/lease$
        Configure the default lease information for generated credentials.

    ^config/root$
        Configure the root credentials that are used to manage IAM.

    ^creds/(?P<name>\w+)$
        Generate an access key pair for a specific role.

    ^roles/(?P<name>\w+)$
        Read and write IAM policies that access keys can be made for.
```
`vault path-help`命令带上一个路径。指定`root`路径，会获得 secrets 引擎的概述。
注意，帮助不仅包含描述，还包含用于匹配该后端路由的精确正则表达式，以及关于路由的简要描述。

### 路径帮助
我们可以通过为单个路径寻求帮助来继续深入研究。为此，只需使用`vault path-help`提供与该路径的正则表达式匹配的路径。
注意，这个路径实际上不需要是正确的。例如，我们将获得以下帮助来访问`aws/creds/my-non-existent-role`，尽管我们从未创建过这个角色:
```bash
$ vault path-help aws/creds/my-non-existent-role

Request:        creds/my-non-existent-role
Matching Route: ^creds/(?P<name>\w(([\w-.]+)?\w)?)$

Generate an access key pair for a specific role.

### PARAMETERS

    name (string)
        Name of the role

### DESCRIPTION

This path will generate a new, never before used key pair for
accessing AWS. The IAM policy used to back this key pair will be
the "name" parameter. For example, if this backend is mounted at "aws",
then "aws/creds/deploy" would generate access keys for the "deploy" role.

The access keys will have a lease associated with them. The access keys
can be revoked by using the lease ID.
```

## Authentication

到目前为止，我们还没有登录到Vault。在 dev 模式下启动 Vault 服务器时，它会自动将您作为具有管理权限的根用户登录。
在非 dev 设置中，必须首先进行身份验证。

身份验证是向Vault用户分配身份的机制。

Vault 具有可插入的 auth 方法，使用最适合你组织的任何形式的Vault很容易进行身份验证。

### 背景

## Policies
## 部署 Vault
## 使用带有身份验证的HTTP APIs