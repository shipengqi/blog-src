---
title: Redis 的过期策略
date: 2018-08-08 10:23:59
categories: ["Linux"]
tags: ["Redis"]
---

在日常开发中，我们使用`Redis`存储`key`时通常会设置一个过期时间，但是`Redis`是怎么删除过期的`key`，而且`Redis`是单线程的，
删除`Key`会不会造成阻塞。要搞清楚这些，就要了解`Redis`的过期策略和内存淘汰机制。

<!-- more -->

`Redis`采用的是定期删除 + 懒惰删除策略。

## 定期删除策略
`Redis`会将每个设置了过期时间的`key`放入到一个独立的字典中，默认每`100ms`进行一次过期扫描：
1. 随机抽取`20`个`key`
2. 删除这`20`个`key`中过期的`key`
3. 如果过期的`key`比例超过`1/4`，就重复步骤`1`，继续删除。

为什不扫描所有的`key`，`Redis`是单线程，全部扫描岂不是卡死了。
而且为了防止每次扫描过期的`key`比例都超过`1/4`，导致不停循环卡死线程，`Redis`为每次扫描添加了上限时间，默认是`25ms`。

如果在同一时间出现大面积`key`过期，`Redis`循环多次扫描过期词典，直到过期的`key`比例小于`1/4`。这会导致卡顿，而且在高并发
的情况下，可能会导致[缓存雪崩](/2018/08/08/redis-expire-strategy/)。

为什么`Redis`为每次扫描添的上限时间是`25ms`，还会出现上面的情况？
因为`Redis`是单线程，每个请求处理都需要排队，而且由于`Redis`每次扫描都是`25ms`，也就是每个请求最多`25ms`，100 个请求就是`2500ms`。

## 懒惰删除策略
懒惰删除策略就是指，在访问某个`key`时，`Redis`判断`key`是否过期，过期了就删除。定期删除是集中处理，惰性删除是零散处理。

## 内存淘汰机制
`Redis`的内存占用会越来越高。`Redis`为了限制最大使用内存，提供了`redis.conf`中的
配置参数`maxmemory`。当内存超出`maxmemory`，`Redis`提供了几种内存淘汰机制让用户选择，配置`maxmemory-policy`：
- `noeviction`：当内存超出`maxmemory`，写入请求会报错，但是删除和读请求可以继续。（使用这个策略，疯了吧）
- `allkeys-lru`：当内存超出`maxmemory`，在所有的`key`中，移除最少使用的`key`。只把`Redis`既当缓存是使用这种策略。（推荐）。
- `allkeys-random`：当内存超出`maxmemory`，在所有的`key`中，随机移除某个 Key。（应该没人用吧）
- `volatile-lru`：当内存超出`maxmemory`，在设置了过期时间`key`的字典中，移除最少使用的`key`。把`Redis`既当缓存，又做持久化的时候使用这种策略。
- `volatile-random`：当内存超出`maxmemory`，在设置了过期时间`key`的字典中，随机移除某个`key`。
- `volatile-ttl`：当内存超出`maxmemory`，在设置了过期时间`key`的字典中，优先移除`ttl`小的。

### 近似 LRU 算法

`Redis`使用的并不是完全`LRU`算法。不使用`LRU`算法，是为了节省内存，`Redis`采用的是随机`LRU`算法，`Redis`为每一个`key`增加了一个`24 bit`的字段，
用来记录这个`key`最后一次被访问的时间戳。**注意`Redis`的`LRU`淘汰策略是懒惰处理**，也就是不会主动执行淘汰策略，当`Redis`执行写操作时，发现内存超出`maxmemory`，
就会执行`LRU`淘汰算法。这个算法就是随机采样出`5`(默认值)个`key`，然后移除最旧的`key`，如果移除后内存还是超出`maxmemory`，那就继续随机采样淘汰，直到内存低于`maxmemory`为止。
随机采样的`key`的个数可以通过参数`maxmemory-samples`配置。